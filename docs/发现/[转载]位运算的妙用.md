转载自[位运算符及其应用](https://blog.csdn.net/hguisu/article/details/7892596)，略有修改

# 一、C语言的六种位运算符：

`& `  $\rightarrow$ **按位与**

`| `  $\rightarrow$ **按位或**

`^ `  $\rightarrow$ **按位异或**

`~ `  $\rightarrow$ **按位取反**

`<<` $\rightarrow$ **左移**

`>>` $\rightarrow$ **右移**

 

## 1.  按位与运算

**按位与运算符"&"是双目运算符。**

​    其功能是参与运算的两数各对应的二进位`相与`。只有对应的两个二进位均为1时，结果位才为1 ，否则为0。参与运算的数以补码方式出现。

例如：9 $\&$ 5可写算式如下： 

```
00001001 (9的二进制补码)
    &
00000101 (5的二进制补码) 
    =
00000001 (1的二进制补码)

```

​     按位与运算通常用来对某些位 `清0` 或保留某些位。例如把a 的高八位清 0 ， 保留低八位， 可作 a&255 运算 ( 255 的二进制数为0000000011111111)。

 

```cpp
int main(){
	int a = 9,b = 5,c;
	c=a & b;
	printf("a=%d\nb=%d\nc=%d\n",a,b,c);
    return 0;
}
```



## 2.按位或运算

**按位或运算符“|”是双目运算符。**

​     其功能是参与运算的两数各对应的二进位`相或`。只要对应的两个二进位有一个为1时，结果位就为1。参与运算的两个数均以补码出现。

例如：9|5可写算式如下： 

```
00001001
   |
00000101
   =
00001101 (13的2进制补码)
```



```cpp
int main(){
	int a = 9,b = 5,c;
	c=a | b;
	printf("a=%d\nb=%d\nc=%d\n",a,b,c);
    return 0;
}
```

## 3.按位异或运算

**按位异或运算符“^”是双目运算符。**

​    其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。参与运算数仍以补码出现。

​    例如9^5可写成算式如下：

```
00001001
   ^
00000101
   =
00001100 (十进制为12)
```

```cpp
int main(){
	int a=9;	
	a=a^15;
	printf("a=%d\n",a);
    return 0;
}
```



## 4. 求反运算

**求反运算符～为单目运算符，具有右结合性。**

​    其功能是对参与运算的数的各二进位按位求反。

例如～9的运算为： ~(0000000000001001)结果为：1111111111110110

 ```
~
0000000000001001
=
1111111111110110
 ```



## 5. 左移运算

**左移运算符“<<”是双目运算符。左移n位就是乘以2的n次方。**

​    其功能把`<<`左边的运算数的各二进位全部左移若干位，由`<<`右边的数指定移动的位数，高位丢弃，低位补0。

​    1）例： a<<4 指把a的各二进位向左移动4位。

```
a = 00000011(十进制3)
b = a << 4
  = 00110000(十进制48)
```

​    2）例：

​     int i = 1;

​     i = i << 2; //把i里的值左移2位

​     也就是说,1的2进制是000...0001(这里1前面0的个数和int的位数有关,32位机器,gcc里有31个0),左移2位之后变成 000...0100,也就是10进制的4,所以说左移1位相当于乘以2,那么左移n位就是乘以2的n次方了(有符号数不完全适用,因为左移有可能导致符号变化,下面解释原因)

​    **需要注意的一个问题是：**int类型最左端的符号位和移位移出去的情况. 我们知道,int是有符号的整形数,最左端的1位是符号位,即0正1负,那么移位的时候就会出现溢出,

​    例如:

```cpp
int i = 0x40000000; //16进制的40000000,为2进制的01000000...0000
i = i << 1;
```

   那么,i在左移1位之后就会变成0x80000000,也就是2进制的100000...0000,符号位被置1,其他位全是0,变成了int类型所能表示的最小值,32位的int这个值是-2147483648,溢出.如果再接着把i左移1位会出现什么情况呢?在C语言中采用了丢弃最高位的处理方法,丢弃了1之后,i的值变成了0.

​    左移里一个比较特殊的情况是当左移的位数超过该数值类型的最大位数时,编译器会用左移的位数去模类型的最大位数,然后按余数进行移位,如:

```cpp
int i = 1, j = 0x80000000; //设int为32位
i = i << 33;  // 33 % 32 = 1 左移1位,i变成2
j = j << 33;  // 33 % 32 = 1 左移1位,j变成0,最高位被丢弃
```

​    在用gcc编译这段程序的时候编译器会给出一个warning,说左移位数>=类型长度.那么实际上i,j移动的就是1位,也就是33%32后的余数.在gcc下是这个规则,别的编译器是不是都一样现在还不清楚.

**总之左移就是: 丢弃最高位,0补最低位**

## 6. 右移运算

**右移运算符“>>”是双目运算符。\右移n位就是除以2的n次方**

其功能是把`>>`左边的运算数的各二进位全部右移若干位，`>>`右边的数指定移动的位数。

例如：

```cpp
设 a=15，a>>2 表示把000001111右移为00000011(十进制3)。
```

应该说明的是，对于有符号数，在右移时，符号位将随同移动。当为正数时， 最高位补0，而为负数时，符号位为1，最高位是补0或是补1 取决于编译系统的规定。Turbo C和很多系统规定为补1。

**右移对符号位的处理和左移不同：**

对于有符号整数来说,比如int类型,右移会保持符号位不变,例如:

int i = 0x80000000;

i = i >> 1; //i的值不会变成0x40000000,而会变成0xc0000000

就是说,对于有符号数， 符号位向右移动后,正数的话补0,负数补1,

对于有符号数，在右移时，符号位将随同移动：

当为正数时， 最高位补0，

而为负数时，符号位为1，

也就是汇编语言中的算术右移.同样当移动的位数超过类型的长度时,会取余数,然后移动余数个位.

最高位是补0或是补1 取决于编译系统的规定。Turbo C和很多系统规定为补1。

负数10100110 >>5(假设字长为8位)，则得到的是 11111101

总之,在C中,左移是逻辑 / 算术左移(两者完全相同),右移是算术右移,会保持符号位不变.实际应用中可以根据情况用左 / 右移做快速的乘 / 除运算,这样会比循环效率高很多. 

```
x = x >> 1	→	x = x / 2
x = x << 1	→	x = x * 2
```

无符号：

```cpp
int main(){
	unsigned a,b;
	printf("input a number: ");
	scanf("%d",&a);
	b = a >> 5;
	b = b & 15;
	printf("a=%d\tb=%d\n",a,b);
 	return 0;
}
```



请再看一例!

```cpp
int main(){
    char a = 'a',b = 'b';
    int p, c, d;
    p = a;
    p = (p << 8) | b;
    d = p & 0xff;
    c = (p & 0xff00) >> 8;
    printf("a=%d\nb=%d\nc=%d\nd=%d\n",a,b,c,d);
}
```



# 二、异或操作的妙用



**1. 使特定位翻转**   要使哪几位翻转就将与其进行`∧`运算的该几位置为１即可。

**2 与０相∧，保留原值.**

**3.交换两个值，不用临时变量.**

我们可以在不用引入其他变量就可以实现变量值的交换

用异或操作可以实现：

```cpp
int main(){
    int a = 1, b = 2;
    a = a ^ b;     //(1)
    b = a ^ b;     //(2)
    a = a ^ b;     //(3)
    cout << a << " " << b << endl;
    return 0;
}
```

异或操作满足结合律和交换律，且由异或操作的性质知道，对于任意一个整数**a^a=0**；

证：

```
(第(2)步中的 a)  b = a^b = (将第(1)步中的 a 代入)  → a ^ b ^  b = a

(第(3)步中的 b)  a = a^b = (将第(1)步中的 a 代入，将第(2)步中的b代入) → a ^ b ^ a ^ b ^ b = b
```



**三 、位与运算**



**1 . 清零**   A数中为１的位，B中相应位为０。然后使二者进行＆运算，即可达到对A清零目的。

**2 . 取一个数中某些指定位**　取数A的某些位，把数B的某些位置1，就把数A的某些位与1按位与即可。

**3 . 保留一位的方法**   数A与数B进行＆运算，数B在数A要保留的位1，其余位为零。

**4 . 判断奇偶性** 将变量 a的奇偶性。a与1做位与运算，若结果是1，则 a是奇数；将 a与1做位与运算，若结果是0，则 a是偶数。



**4、应用举例**

**1 .判断int型变量a是奇数还是偶数**      

`a & 1  = 0 偶数`

`a & 1 =  1 奇数`

**2 . 取int型变量a的第k位**

(k = 0,1,2……sizeof(int))，即`a >> k & 1`

**3 . 将int型变量a的第k位清0**，即`a = a & ~(1 << k)`

**4 . 将int型变量a的第k位置1**， 即`a = a | (1 << k)`

**5 . int型变量循环左移k次**，即`a = a << k  `

**6 . int型变量a循环右移k次**，即`a = a >> k  `

**7. 整数的平均值**

对于两个整数`x, y`，如果用 `(x+y)/2` 求平均值，会产生溢出，因为 x+y 可能会大于 INT_MAX，但是我们知道它们的平均值是肯定不会溢出

```cpp
int average(int x, int y)  //返回X,Y 的平均值
{ 
   return (x & y) + ( (x ^ y) >> 1);
}
```

**8 . 判断一个整数是不是2的幂,对于一个数 x >= 0，判断他是不是2的幂**

```cpp
boolean power2(int x)
{
    return (( x & ( x - 1)) == 0) && (x != 0)；
}
```



**9 不用temp交换两个整数**

```cpp
void swap(int x , int y)
{
	x ^= y;
	y ^= x;
	x ^= y;
}
```

**10 计算绝对值**

```cpp
int abs( int x )
{
	int y ;
    y = x >> 31 ;
    return (x ^ y) - y ;    //or: (x+y)^y
}
```



**11. 取模运算转化成位运算 (在不产生溢出的情况下)**

​    ` a % (2 ^ n) 等价于 a & (2^n - 1)`

**12 乘法运算转化成位运算 (在不产生溢出的情况下)**

​     `a * (2 ^ n) 等价于 a<< n`

**13. 除法运算转化成位运算 (在不产生溢出的情况下)**

​     `a / (2 ^ n) 等价于 a>> n`
​    例: 12 / 8 == 12>>3

**14 . 取模运算**

`a % 2 等价于 a & 1  ( a  & log2(2))    `

`a % 4 等价于 a & 2  ( a  & log2(4))  `

**15 .** 

```cpp
if (x == a) 
    x = b;
else 
    x = a;
```

 等价于 **x = a ^ b ^ x**;

**16 . 相反数**

`x 的 相反数 表示为 (~x+1)`