## 496、下一个更大元素I

给你两个 没有重复元素 的数组 `nums1 `和 `nums2 `，其中`nums1 `是 `nums2 `的**子集**。

请你找出 `nums1 `中每个元素在 `nums2 `中的下一个比其大的值。

`nums1 `中数字 `x `的下一个更大元素是指 `x` 在 `nums2 `中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

**示例 1:**

```
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。
    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。
    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```

**示例 2:**

```
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```

**提示：**

$1 <= nums1.length <= nums2.length <= 1000$

$0 <= nums1[i],\space  nums2[i] <= 10^4$

$nums1$ 和 $nums2$ 中所有整数 互不相同

$nums1 $ 中的所有整数同样出现在 $nums2 $ 中



## 题解

主要思想：**单调栈**，若不了解请先看[【转载】单调栈](/docs/发现/[转载]单调栈.md)

本题最重要的一点是`nums1`是`nums2`的子集，因此，我们可以直接在`nums2`数组中求每个元素的下一个更大元素，存放到哈希表中，最后遍历一次哈希表即可。

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> num2index;
        stack<int> s;
        vector<int>res;
        for(int i = nums2.size()-1; i >= 0; i--){
            while( !s.empty() && nums2[i] >= s.top() ){
                s.pop();
            }
            s.empty() ? num2index[nums2[i]] = -1 : num2index[nums2[i]] = s.top();
            s.push(nums2[i]);
        }
        for(int i = 0; i < nums1.size();i++){
            res.push_back( num2index[nums1[i]] );
        }
        return res;
    }
};
```

<div align=right>
    2021年2月17日
</div>

